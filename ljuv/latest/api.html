<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>API :: ljuv Documentation</title>
    <link rel="canonical" href="https://imagicthecat.github.io/ljuv/ljuv/latest/api.html">
    <link rel="prev" href="index.html">
    <meta name="generator" content="Antora 3.1.3">
    <link rel="stylesheet" href="../../_/css/site.css">
    <script>var uiRootPath = '../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://imagicthecat.github.io/ljuv">ljuv Documentation</a>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field">
          <input id="search-input" type="text" placeholder="Search the docs">
        </div>
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <a class="navbar-item" href="https://github.com/ImagicTheCat/ljuv">GitHub</a>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="ljuv" data-version="latest">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="index.html">ljuv</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="api.html">API</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">ljuv</span>
    <span class="version">latest</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="index.html">ljuv</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="index.html">latest</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="index.html">ljuv</a></li>
    <li><a href="api.html">API</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">API</h1>
<div class="sect1">
<h2 id="_basics"><a class="anchor" href="#_basics"></a>Basics</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_ljuv_loop"><a class="anchor" href="#_ljuv_loop"></a>ljuv.loop</h3>
<div class="paragraph">
<p>Default loop, lazily created.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ljuv_assertcode"><a class="anchor" href="#_ljuv_assertcode"></a>ljuv.assert(code)</h3>
<div class="paragraph">
<p>Assert a <strong>libuv</strong> error code.</p>
</div>
</div>
<div class="sect2">
<h3 id="_loop"><a class="anchor" href="#_loop"></a>Loop</h3>
<div class="sect3">
<h4 id="_ljuv_new_loop"><a class="anchor" href="#_ljuv_new_loop"></a>ljuv.new_loop()</h4>
<div class="paragraph">
<p>Create a loop.</p>
</div>
</div>
<div class="sect3">
<h4 id="loop-run"><a class="anchor" href="#loop-run"></a>loop:run([mode])</h4>
<div class="dlist">
<dl>
<dt class="hdlist1">mode</dt>
<dd>
<p>string: <code>default</code>, <code>once</code> or <code>nowait</code></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Returns a boolean status, <strong>true</strong> if there is work left in the loop and the function should be called again, <strong>false</strong> otherwise.</p>
</div>
</div>
<div class="sect3">
<h4 id="_loopalive"><a class="anchor" href="#_loopalive"></a>loop:alive()</h4>
<div class="paragraph">
<p>Returns a boolean.</p>
</div>
</div>
<div class="sect3">
<h4 id="loop-stop"><a class="anchor" href="#loop-stop"></a>loop:stop()</h4>
<div class="paragraph">
<p>Stop the loop.</p>
</div>
</div>
<div class="sect3">
<h4 id="_loopnow"><a class="anchor" href="#_loopnow"></a>loop:now()</h4>
<div class="paragraph">
<p>Get the current loop time (in seconds).</p>
</div>
</div>
<div class="sect3">
<h4 id="_loopupdate_time"><a class="anchor" href="#_loopupdate_time"></a>loop:update_time()</h4>
<div class="paragraph">
<p>Update the current loop time.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_handle"><a class="anchor" href="#_handle"></a>Handle</h3>
<div class="sect3">
<h4 id="_handleis_active"><a class="anchor" href="#_handleis_active"></a>handle:is_active()</h4>
<div class="paragraph">
<p>Returns a boolean.</p>
</div>
</div>
<div class="sect3">
<h4 id="_handleget_loop"><a class="anchor" href="#_handleget_loop"></a>handle:get_loop()</h4>
<div class="paragraph">
<p>Get the associated loop. Returns <code>nil</code> if the loop is already released.</p>
</div>
</div>
<div class="sect3">
<h4 id="_handleget_type"><a class="anchor" href="#_handleget_type"></a>handle:get_type()</h4>
<div class="paragraph">
<p>Get the handle type.</p>
</div>
<div class="paragraph">
<p>Returns a string defined by <code>uv_handle_type_name</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="handle-close"><a class="anchor" href="#handle-close"></a>handle:close()</h4>
<div class="paragraph">
<p>Close the handle. Idempotent.</p>
</div>
<div class="paragraph">
<p>Subsequent use of the handle will throw an error.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_multi_threading"><a class="anchor" href="#_multi_threading"></a>Multi-threading</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_shared_flag"><a class="anchor" href="#_shared_flag"></a>Shared flag</h3>
<div class="sect3">
<h4 id="_ljuv_new_shared_flagvalue_final_value"><a class="anchor" href="#_ljuv_new_shared_flagvalue_final_value"></a>ljuv.new_shared_flag(value [, final_value])</h4>
<div class="paragraph">
<p>Create a shared flag.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">value</dt>
<dd>
<p>integer (C <code>int</code>)</p>
</dd>
<dt class="hdlist1">final_value</dt>
<dd>
<p>same as <em>value</em>, but set at finalization</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_shared_flagsetvalue"><a class="anchor" href="#_shared_flagsetvalue"></a>shared_flag:set(value)</h4>
<div class="paragraph">
<p>Set the shared flag&#8217;s value.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">value</dt>
<dd>
<p>integer (C <code>int</code>)</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_shared_flagget"><a class="anchor" href="#_shared_flagget"></a>shared_flag:get()</h4>
<div class="paragraph">
<p>Returns the shared flag&#8217;s value.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_channel"><a class="anchor" href="#_channel"></a>Channel</h3>
<div class="sect3">
<h4 id="_ljuv_new_channel"><a class="anchor" href="#_ljuv_new_channel"></a>ljuv.new_channel()</h4>
<div class="paragraph">
<p>Create a channel.</p>
</div>
</div>
<div class="sect3">
<h4 id="_channelpush"><a class="anchor" href="#_channelpush"></a>channel:push(&#8230;&#8203;)</h4>
<div class="paragraph">
<p>Push a message.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">&#8230;&#8203;</dt>
<dd>
<p>payload arguments</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_channelpull"><a class="anchor" href="#_channelpull"></a>channel:pull()</h4>
<div class="paragraph">
<p>Pull a message (blocking).</p>
</div>
<div class="paragraph">
<p>Returns payload arguments.</p>
</div>
</div>
<div class="sect3">
<h4 id="_channeltry_pull"><a class="anchor" href="#_channeltry_pull"></a>channel:try_pull()</h4>
<div class="paragraph">
<p>Pull a message (non-blocking).</p>
</div>
<div class="paragraph">
<p>Returns a boolean status, <strong>true</strong> followed by the payload arguments if a message has been pulled, or <strong>false</strong> otherwise.</p>
</div>
</div>
<div class="sect3">
<h4 id="_channelcount"><a class="anchor" href="#_channelcount"></a>channel:count()</h4>
<div class="paragraph">
<p>Count the number of pending messages.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_object_transfer"><a class="anchor" href="#_object_transfer"></a>Object transfer</h3>
<div class="sect3">
<h4 id="_ljuv_exporto_soft"><a class="anchor" href="#_ljuv_exporto_soft"></a>ljuv.export(o [, soft])</h4>
<div class="paragraph">
<p>Export an object to be passed to another thread.</p>
</div>
<div class="dlist">
<div class="title">Exportables</div>
<dl>
<dt class="hdlist1">channel</dt>
<dt class="hdlist1">shared flag</dt>
<dt class="hdlist1">async handle</dt>
<dd>
<p>imported as a function which safely calls <a href="#api-loop.adoc#async-send" class="xref unresolved">async:send</a></p>
</dd>
</dl>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The returned payload must be imported exactly once to prevent memory leak and invalid memory accesses.
</td>
</tr>
</table>
</div>
<div class="dlist">
<div class="title">Parameters</div>
<dl>
<dt class="hdlist1">o</dt>
<dd>
<p>object to export</p>
</dd>
<dt class="hdlist1">soft</dt>
<dd>
<p>truthy to not throw errors on invalid object (returns nothing)</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Returns a payload encodable by String Buffers.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ljuv_importpayload_soft"><a class="anchor" href="#_ljuv_importpayload_soft"></a>ljuv.import(payload [, soft])</h4>
<div class="paragraph">
<p>Import an object payload.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">payload</dt>
<dt class="hdlist1">soft</dt>
<dd>
<p>truthy to not throw errors on invalid payload (returns nothing)</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Returns imported object.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_high_level_abstractions"><a class="anchor" href="#_high_level_abstractions"></a>High-level abstractions</h3>
<div class="sect3">
<h4 id="_loopthreadentry_callback"><a class="anchor" href="#_loopthreadentry_callback"></a>loop:thread(entry, callback, &#8230;&#8203;)</h4>
<div class="paragraph">
<p>Create a new system-thread and run a Lua function asynchronously.</p>
</div>
<div class="paragraph">
<p>The created Lua state inherits from the current values of <code>package.path</code> and <code>package.cpath</code>.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
The loop will not synchronously wait on running threads if garbage collected; the application should asynchronously wait on the callback.
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">entry</dt>
<dd>
<p>thread entry function, a Lua function or a string of Lua code/bytecode</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It uses <code>string.dump</code> to convert the Lua function to bytecode. Nothing will be done about the function&#8217;s upvalues.
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1">callback(ok, &#8230;&#8203;)</dt>
<dd>
<p>Called when terminated; common soft error handling interface: returns <strong>ok</strong> status followed by an error message or the function return values (encoded by String Buffers).</p>
</dd>
<dt class="hdlist1">&#8230;&#8203;</dt>
<dd>
<p>arguments passed to the function, must be encodable by String Buffers</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_loopthreadpoolthread_count_interface_loader"><a class="anchor" href="#_loopthreadpoolthread_count_interface_loader"></a>loop:threadpool(thread_count, interface_loader)</h4>
<div class="paragraph">
<p>Create a thread pool.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">thread_count</dt>
<dd>
<p>number of threads in the pool</p>
</dd>
<dt class="hdlist1">interface_loader</dt>
<dd>
<p>Lua function or code, plain or bytecode, which returns a map of functions (called from worker threads)</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_threadpoolcallop_callback"><a class="anchor" href="#_threadpoolcallop_callback"></a>threadpool:call(op, callback, &#8230;&#8203;)</h4>
<div class="paragraph">
<p>Call an operation on the thread pool interface.</p>
</div>
<div class="paragraph">
<p>The callback can be a coroutine (will call <code>coroutine.resume</code> with the same parameters).</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">op</dt>
<dd>
<p>key to an operation of the interface</p>
</dd>
<dt class="hdlist1">callback(ok, &#8230;&#8203;)</dt>
<dd>
<p>Called on operation return, common soft error handling interface: returns <strong>ok</strong> status followed by an error message or the function return values (encoded by String Buffers).</p>
</dd>
<dt class="hdlist1">&#8230;&#8203;</dt>
<dd>
<p>call arguments (encoded by String Buffers)</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_threadpoolclose"><a class="anchor" href="#_threadpoolclose"></a>threadpool:close()</h4>
<div class="paragraph">
<p>Close the thread pool (send exit signal to all threads). Idempotent.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
There are no mechanisms to directly wait on the termination of the threadpool, because only the application knows the context of the work it has to do. I.e. this method should be called when all work is done.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_timers"><a class="anchor" href="#_timers"></a>Timers</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_looptimer"><a class="anchor" href="#_looptimer"></a>loop:timer()</h3>
<div class="paragraph">
<p>Create a timer handle.</p>
</div>
</div>
<div class="sect2">
<h3 id="_timerstarttimeout_repeat_period_callback"><a class="anchor" href="#_timerstarttimeout_repeat_period_callback"></a>timer:start(timeout, repeat_period, callback)</h3>
<div class="paragraph">
<p>Start the timer.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">timeout</dt>
<dd>
<p>first timeout in seconds</p>
</dd>
<dt class="hdlist1">repeat_period</dt>
<dd>
<p>repeat period in seconds, <code>0</code> to disable</p>
</dd>
<dt class="hdlist1">callback</dt>
<dd>
<p><code>(timer)</code></p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_timerstop"><a class="anchor" href="#_timerstop"></a>timer:stop()</h3>
<div class="paragraph">
<p>Stop the timer.</p>
</div>
</div>
<div class="sect2">
<h3 id="_timeragain"><a class="anchor" href="#_timeragain"></a>timer:again()</h3>
<div class="paragraph">
<p>Stop the timer, and if it is repeating restart it using the repeat value as the timeout.</p>
</div>
</div>
<div class="sect2">
<h3 id="_timerset_repeatperiod"><a class="anchor" href="#_timerset_repeatperiod"></a>timer:set_repeat(period)</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">period</dt>
<dd>
<p>repeat period in seconds, <code>0</code> to disable</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_timerget_repeat"><a class="anchor" href="#_timerget_repeat"></a>timer:get_repeat()</h3>
<div class="paragraph">
<p>Get the repeat period (in seconds).</p>
</div>
</div>
<div class="sect2">
<h3 id="_timerget_due_in"><a class="anchor" href="#_timerget_due_in"></a>timer:get_due_in()</h3>
<div class="paragraph">
<p>Get the timer due value (in seconds, <code>0</code> if expired).</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_async"><a class="anchor" href="#_async"></a>Async</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_loopasynccallback"><a class="anchor" href="#_loopasynccallback"></a>loop:async(callback)</h3>
<div class="paragraph">
<p>Create an async handle.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">callback</dt>
<dd>
<p><code>(async)</code></p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="async-send"><a class="anchor" href="#async-send"></a>async:send()</h3>
<div class="paragraph">
<p>Wake up the event loop and call the async handleâ€™s callback.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_signals"><a class="anchor" href="#_signals"></a>Signals</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_loopsignal"><a class="anchor" href="#_loopsignal"></a>loop:signal()</h3>
<div class="paragraph">
<p>Create a signal handle.</p>
</div>
</div>
<div class="sect2">
<h3 id="_signalstartsignum_callback"><a class="anchor" href="#_signalstartsignum_callback"></a>signal:start(signum, callback)</h3>
<div class="paragraph">
<p>Start watching for the given signal.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">signum</dt>
<dd>
<p>signal number</p>
</dd>
<dt class="hdlist1">callback</dt>
<dd>
<p><code>(signal, signum)</code></p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_signalstart_oneshotsignum_callback"><a class="anchor" href="#_signalstart_oneshotsignum_callback"></a>signal:start_oneshot(signum, callback)</h3>
<div class="paragraph">
<p>Same as <code>start()</code>, but the signal handler is reset the moment the signal is received.</p>
</div>
</div>
<div class="sect2">
<h3 id="_signalstop"><a class="anchor" href="#_signalstop"></a>signal:stop()</h3>
<div class="paragraph">
<p>Stop watching for signals.</p>
</div>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="index.html">ljuv</a></span>
</nav>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script id="site-script" src="../../_/js/site.js" data-ui-root-path="../../_"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
<script src="../../_/js/vendor/lunr.js"></script>
<script src="../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../.." data-snippet-length="100" data-stylesheet="../../_/css/search.css"></script>
<script async src="../../search-index.js"></script>
  </body>
</html>

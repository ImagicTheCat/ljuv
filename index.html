<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.16">
<title>ljuv Documentation</title>
<style>
/* Based on https://github.com/darshandsoni/asciidoctor-skins (material teal). */
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */

@import url(//fonts.googleapis.com/css?family=Noto+Sans);
@import url(https://cdn.jsdelivr.net/gh/asciidoctor/asciidoctor@2.0/data/stylesheets/asciidoctor-default.css); /* Default asciidoc style framework - important */

/* CUSTOMISATIONS */
/* Change the values in root for quick customisation. If you want even more fine grain... venture further. */

:root{
--maincolor:#FFFFFF;
--primarycolor:#009688; /* Teal 500 */
--secondarycolor:#ba3925;
--tertiarycolor: #186d7a;
--sidebarbackground:#004d40; /* Teal 900 */
--linkcolor:#00aa9b;
--linkcoloralternate:#f44336;
--white:#FFFFFF;
--black:#000000;
}

body{font-family: "Noto Sans",sans-serif;}

#header{background-color:var(--primarycolor); padding:25px;max-width: none;}
#footer{background-color: var(--sidebarbackground);}
h1,h2,h3{background-color:var(--primarycolor);color:var(--white) !important;font-family:"Noto Sans",sans-serif;text-decoration:none;padding:10px;}
h4,h5,h6{color:var(--primarycolor);}
.title{color:var(--sidebarbackground) !important;font-family:"Noto Sans",sans-serif;font-style: normal; font-weight: normal;}
p{font-family: "Noto Sans",sans-serif ! important}

#toc a:hover{ color:white; }
#toc a{ color: #80cbc4; /* Teal 200 */ }

a {
  text-decoration: none;
  color: var(--linkcolor);
}
a:hover {
  color: var(--sidebarbackground);
}
.quoteblock blockquote::before {
  color: var(--linkcolor);
}
mark {
  color: var(--white);
  background-color: #80cbc4;
}

/* Card styling */
.sect1{border-bottom:1px solid grey;border-radius:8px;}

/* Table styles */
th{background-color: #80cbc4;color:#FFFFFF;}

#toc.toc2{background-color:var(--sidebarbackground);color:white !important;}
#toc.toc2.a{color:var(--white);}
#toc.toc2.a:active{color:var(--white) !important;}
#toc.toc2.a:visited{color:var(--white) !important;}
#toctitle{color:white;font-size: 16px;}

/* Responsiveness fixes */
video {
  max-width: 100%;
}

@media all and (max-width: 600px) {
table {
  width: 55vw!important;
  font-size: 3vw;
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>ljuv Documentation</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_levels_of_abstraction">Levels of abstraction</a></li>
<li><a href="#_error_handling">Error handling</a>
<ul class="sectlevel2">
<li><a href="#_callbacks">Callbacks</a></li>
</ul>
</li>
<li><a href="#_resources_management">Resources management</a>
<ul class="sectlevel2">
<li><a href="#_loop_and_handles">Loop and handles</a></li>
<li><a href="#_shared_objects">Shared objects</a></li>
</ul>
</li>
<li><a href="#_string_buffers">String buffers</a></li>
<li><a href="#_api_reference">API Reference</a>
<ul class="sectlevel2">
<li><a href="#_ljuv_loop">ljuv.loop</a></li>
<li><a href="#_ljuv_assertcode">ljuv.assert(code)</a></li>
<li><a href="#_ljuv_exporto_soft">ljuv.export(o [, soft])</a></li>
<li><a href="#_ljuv_importpayload_soft">ljuv.import(payload [, soft])</a></li>
<li><a href="#_ljuv_new_shared_flagvalue_final_value">ljuv.new_shared_flag(value [, final_value])</a></li>
<li><a href="#_shared_flagsetvalue">shared_flag:set(value)</a></li>
<li><a href="#_shared_flagget">shared_flag:get()</a></li>
<li><a href="#_ljuv_new_channel">ljuv.new_channel()</a></li>
<li><a href="#_channelpush">channel:push(&#8230;&#8203;)</a></li>
<li><a href="#_channelpull">channel:pull()</a></li>
<li><a href="#_channeltry_pull">channel:try_pull()</a></li>
<li><a href="#_channelcount">channel:count()</a></li>
<li><a href="#_ljuv_new_threadfunc">ljuv.new_thread(func, &#8230;&#8203;)</a></li>
<li><a href="#_threadrunning">thread:running()</a></li>
<li><a href="#thread-join">thread:join()</a></li>
<li><a href="#_ljuv_new_loop">ljuv.new_loop()</a></li>
<li><a href="#loop-run">loop:run([mode])</a></li>
<li><a href="#_loopalive">loop:alive()</a></li>
<li><a href="#loop-stop">loop:stop()</a></li>
<li><a href="#_loopnow">loop:now()</a></li>
<li><a href="#_loopupdate_time">loop:update_time()</a></li>
<li><a href="#_handleis_active">handle:is_active()</a></li>
<li><a href="#_handleget_loop">handle:get_loop()</a></li>
<li><a href="#_handleget_type">handle:get_type()</a></li>
<li><a href="#handle-close">handle:close()</a></li>
<li><a href="#_looptimer">loop:timer()</a></li>
<li><a href="#_timerstarttimeout_repeat_period_callback">timer:start(timeout, repeat_period, callback)</a></li>
<li><a href="#_timerstop">timer:stop()</a></li>
<li><a href="#_timeragain">timer:again()</a></li>
<li><a href="#_timerset_repeatperiod">timer:set_repeat(period)</a></li>
<li><a href="#_timerget_repeat">timer:get_repeat()</a></li>
<li><a href="#_timerget_due_in">timer:get_due_in()</a></li>
<li><a href="#_loopasynccallback">loop:async(callback)</a></li>
<li><a href="#async-send">async:send()</a></li>
<li><a href="#_loopsignal">loop:signal()</a></li>
<li><a href="#_signalstartsignum_callback">signal:start(signum, callback)</a></li>
<li><a href="#_signalstart_oneshotsignum_callback">signal:start_oneshot(signum, callback)</a></li>
<li><a href="#_signalstop">signal:stop()</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://github.com/ImagicTheCat/ljuv"><strong>ljuv</strong></a> is a Lua library built on <a href="https://libuv.org/">libuv</a> and <a href="https://luajit.org/">LuaJIT</a> 2.1 (HEAD).</p>
</div>
<div class="paragraph">
<p>A main event loop combined with coroutines can be a way to nicely parallelize and synchronize various operations, which is what computing is mostly about.</p>
</div>
<div class="paragraph">
<p>Not only a binding to <strong>libuv</strong>, the library aims to expose different levels of abstraction and address problems like multi-threading.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When the documentation is very succinct because it is just a layer above the <strong>libuv</strong> API, refer to the <strong>libuv</strong> documentation.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_levels_of_abstraction"><a class="anchor" href="#_levels_of_abstraction"></a>Levels of abstraction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If the regular API is too high level, e.g. poor performance or some features are missing, the <strong>ljuv</strong> submodules may be directly used:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ljuv.libuv</code></dt>
<dd>
<p>The FFI binding and library namespace of <strong>libuv</strong> (not exhaustive).</p>
</dd>
<dt class="hdlist1"><code>ljuv.wrapper</code></dt>
<dd>
<p>The <strong>ljuv</strong> C API, which is used to implement additional features like thread and channel.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_error_handling"><a class="anchor" href="#_error_handling"></a>Error handling</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_callbacks"><a class="anchor" href="#_callbacks"></a>Callbacks</h3>
<div class="paragraph">
<p>Errors from loop callbacks are properly handled; they will be deferred, queued and propagated by <a href="#loop-run">loop:run([mode])</a> as soon as possible (with a call to <a href="#loop-stop">loop:stop()</a>). After an error, the state of the loop is still valid and <a href="#loop-run">loop:run([mode])</a> can be called again to propagate the next error or to continue execution.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In most cases catching errors from <a href="#loop-run">loop:run([mode])</a>, the root of the application, is not meaningful and should probably be done at the callback level instead.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources_management"><a class="anchor" href="#_resources_management"></a>Resources management</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_loop_and_handles"><a class="anchor" href="#_loop_and_handles"></a>Loop and handles</h3>
<div class="paragraph">
<p>Handles are created and owned by a loop, they are not garbage collected on their own. To release an handle and its resources, <a href="#handle-close">handle:close()</a> must be called. A loop will close its handles when garbage collected.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Due to the design of <strong>ljuv</strong>, if an handle callback is an anchor for the associated loop, e.g. it has a reference to it directly or indirectly by its upvalues, the loop will not be garbage collected until the VM is closed. For most applications it doesn&#8217;t matter because they will use the default global loop as their main event loop.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Although <strong>ljuv</strong> uses <strong>cdata</strong> objects, care is taken to preserve their identity in the API. When an handle is passed to a callback it will be the same <strong>cdata</strong> object created by the loop. That <strong>cdata</strong> object identifies the handle and can be used as a key.</p>
</div>
</div>
<div class="sect2">
<h3 id="_shared_objects"><a class="anchor" href="#_shared_objects"></a>Shared objects</h3>
<div class="paragraph">
<p>Objects like <strong>channels</strong> or <strong>shared flags</strong> are properly managed from multiple threads by the use of reference counting (if correctly exported/imported).</p>
</div>
<div class="paragraph">
<p>An <strong>async</strong> handle exported to another thread will act more as a weak reference: the validity of the handle is checked before attempting an operation.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_string_buffers"><a class="anchor" href="#_string_buffers"></a>String buffers</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>ljuv</strong> uses LuaJIT&#8217;s string buffers to pass data between threads. Look at the LuaJIT documentation to know about what kind of data is supported.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_api_reference"><a class="anchor" href="#_api_reference"></a>API Reference</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_ljuv_loop"><a class="anchor" href="#_ljuv_loop"></a>ljuv.loop</h3>
<div class="paragraph">
<p>Default loop, lazily created.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ljuv_assertcode"><a class="anchor" href="#_ljuv_assertcode"></a>ljuv.assert(code)</h3>
<div class="paragraph">
<p>Assert a <strong>libuv</strong> error code.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ljuv_exporto_soft"><a class="anchor" href="#_ljuv_exporto_soft"></a>ljuv.export(o [, soft])</h3>
<div class="paragraph">
<p>Export an object to be passed to another thread.</p>
</div>
<div class="dlist">
<div class="title">Exportables</div>
<dl>
<dt class="hdlist1">channel</dt>
<dt class="hdlist1">shared flag</dt>
<dt class="hdlist1">async handle</dt>
<dd>
<p>imported as a function which safely calls <a href="#async-send">async:send()</a></p>
</dd>
</dl>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The returned payload must be imported exactly once to prevent memory leak and invalid memory accesses.
</td>
</tr>
</table>
</div>
<div class="dlist">
<div class="title">Parameters</div>
<dl>
<dt class="hdlist1">o</dt>
<dd>
<p>object to export</p>
</dd>
<dt class="hdlist1">soft</dt>
<dd>
<p>truthy to not throw errors on invalid object (returns nothing)</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Returns a payload encodable by String Buffers.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ljuv_importpayload_soft"><a class="anchor" href="#_ljuv_importpayload_soft"></a>ljuv.import(payload [, soft])</h3>
<div class="paragraph">
<p>Import an object payload.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">payload</dt>
<dt class="hdlist1">soft</dt>
<dd>
<p>truthy to not throw errors on invalid payload (returns nothing)</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Returns imported object.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ljuv_new_shared_flagvalue_final_value"><a class="anchor" href="#_ljuv_new_shared_flagvalue_final_value"></a>ljuv.new_shared_flag(value [, final_value])</h3>
<div class="paragraph">
<p>Create a shared flag.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">value</dt>
<dd>
<p>integer (C <code>int</code>)</p>
</dd>
<dt class="hdlist1">final_value</dt>
<dd>
<p>same as <em>value</em>, but set at finalization</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_shared_flagsetvalue"><a class="anchor" href="#_shared_flagsetvalue"></a>shared_flag:set(value)</h3>
<div class="paragraph">
<p>Set the shared flag&#8217;s value.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">value</dt>
<dd>
<p>integer (C <code>int</code>)</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_shared_flagget"><a class="anchor" href="#_shared_flagget"></a>shared_flag:get()</h3>
<div class="paragraph">
<p>Returns the shared flag&#8217;s value.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ljuv_new_channel"><a class="anchor" href="#_ljuv_new_channel"></a>ljuv.new_channel()</h3>
<div class="paragraph">
<p>Create a channel.</p>
</div>
</div>
<div class="sect2">
<h3 id="_channelpush"><a class="anchor" href="#_channelpush"></a>channel:push(&#8230;&#8203;)</h3>
<div class="paragraph">
<p>Push a message.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">&#8230;&#8203;</dt>
<dd>
<p>payload arguments</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_channelpull"><a class="anchor" href="#_channelpull"></a>channel:pull()</h3>
<div class="paragraph">
<p>Pull a message (blocking).</p>
</div>
<div class="paragraph">
<p>Returns payload arguments.</p>
</div>
</div>
<div class="sect2">
<h3 id="_channeltry_pull"><a class="anchor" href="#_channeltry_pull"></a>channel:try_pull()</h3>
<div class="paragraph">
<p>Pull a message (non-blocking).</p>
</div>
<div class="paragraph">
<p>Returns a boolean status, <strong>true</strong> followed by the payload arguments if a message has been pulled, or <strong>false</strong> otherwise.</p>
</div>
</div>
<div class="sect2">
<h3 id="_channelcount"><a class="anchor" href="#_channelcount"></a>channel:count()</h3>
<div class="paragraph">
<p>Count the number of pending messages.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ljuv_new_threadfunc"><a class="anchor" href="#_ljuv_new_threadfunc"></a>ljuv.new_thread(func, &#8230;&#8203;)</h3>
<div class="paragraph">
<p>Create a thread.</p>
</div>
<div class="paragraph">
<p>The created Lua state inherits from the current values of <code>package.path</code> and <code>package.cpath</code>.</p>
</div>
<div class="paragraph">
<p>It attempts to export each argument which allows, for example, to pass a channel without manual calls to export/import.</p>
</div>
<div class="paragraph">
<p>Nothing will be done about the function&#8217;s upvalues as it would be semantically incorrect to transfer them (a Lua upvalue is a reference to an outer local, not just a value).</p>
</div>
<div class="paragraph">
<p>The function&#8217;s return values, encoded by String Buffers, will be returned by <a href="#thread-join">thread:join()</a> on successful completion.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">func</dt>
<dd>
<p>thread entry function, a Lua function or a string of Lua code/bytecode</p>
</dd>
<dt class="hdlist1">&#8230;&#8203;</dt>
<dd>
<p>arguments passed to the function, must be encodable by String Buffers</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_threadrunning"><a class="anchor" href="#_threadrunning"></a>thread:running()</h3>
<div class="paragraph">
<p>Check if the thread is still running. Returns a boolean.</p>
</div>
</div>
<div class="sect2">
<h3 id="thread-join"><a class="anchor" href="#thread-join"></a>thread:join()</h3>
<div class="paragraph">
<p>Join the thread (blocking).</p>
</div>
<div class="paragraph">
<p>Also releases the thread resources.</p>
</div>
<div class="paragraph">
<p>Returns a boolean status, <strong>true</strong> followed by the thread function return values on successful completion, or <strong>false</strong> followed by an error traceback on failure.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ljuv_new_loop"><a class="anchor" href="#_ljuv_new_loop"></a>ljuv.new_loop()</h3>
<div class="paragraph">
<p>Create a loop.</p>
</div>
</div>
<div class="sect2">
<h3 id="loop-run"><a class="anchor" href="#loop-run"></a>loop:run([mode])</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">mode</dt>
<dd>
<p>string: <code>default</code>, <code>once</code> or <code>nowait</code></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Returns a boolean status, <strong>true</strong> if there is work left in the loop and the function should be called again, <strong>false</strong> otherwise.</p>
</div>
</div>
<div class="sect2">
<h3 id="_loopalive"><a class="anchor" href="#_loopalive"></a>loop:alive()</h3>
<div class="paragraph">
<p>Returns a boolean.</p>
</div>
</div>
<div class="sect2">
<h3 id="loop-stop"><a class="anchor" href="#loop-stop"></a>loop:stop()</h3>
<div class="paragraph">
<p>Stop the loop.</p>
</div>
</div>
<div class="sect2">
<h3 id="_loopnow"><a class="anchor" href="#_loopnow"></a>loop:now()</h3>
<div class="paragraph">
<p>Get the current loop time (in seconds).</p>
</div>
</div>
<div class="sect2">
<h3 id="_loopupdate_time"><a class="anchor" href="#_loopupdate_time"></a>loop:update_time()</h3>
<div class="paragraph">
<p>Update the current loop time.</p>
</div>
</div>
<div class="sect2">
<h3 id="_handleis_active"><a class="anchor" href="#_handleis_active"></a>handle:is_active()</h3>
<div class="paragraph">
<p>Returns a boolean.</p>
</div>
</div>
<div class="sect2">
<h3 id="_handleget_loop"><a class="anchor" href="#_handleget_loop"></a>handle:get_loop()</h3>
<div class="paragraph">
<p>Get the associated loop. Returns <code>nil</code> if the loop is already released.</p>
</div>
</div>
<div class="sect2">
<h3 id="_handleget_type"><a class="anchor" href="#_handleget_type"></a>handle:get_type()</h3>
<div class="paragraph">
<p>Get the handle type.</p>
</div>
<div class="paragraph">
<p>Returns a string defined by <code>uv_handle_type_name</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="handle-close"><a class="anchor" href="#handle-close"></a>handle:close()</h3>
<div class="paragraph">
<p>Close the handle. Idempotent.</p>
</div>
<div class="paragraph">
<p>Subsequent use of the handle will throw an error.</p>
</div>
</div>
<div class="sect2">
<h3 id="_looptimer"><a class="anchor" href="#_looptimer"></a>loop:timer()</h3>
<div class="paragraph">
<p>Create a timer handle.</p>
</div>
</div>
<div class="sect2">
<h3 id="_timerstarttimeout_repeat_period_callback"><a class="anchor" href="#_timerstarttimeout_repeat_period_callback"></a>timer:start(timeout, repeat_period, callback)</h3>
<div class="paragraph">
<p>Start the timer.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">timeout</dt>
<dd>
<p>first timeout in seconds</p>
</dd>
<dt class="hdlist1">repeat_period</dt>
<dd>
<p>repeat period in seconds, <code>0</code> to disable</p>
</dd>
<dt class="hdlist1">callback</dt>
<dd>
<p><code>(timer)</code></p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_timerstop"><a class="anchor" href="#_timerstop"></a>timer:stop()</h3>
<div class="paragraph">
<p>Stop the timer.</p>
</div>
</div>
<div class="sect2">
<h3 id="_timeragain"><a class="anchor" href="#_timeragain"></a>timer:again()</h3>
<div class="paragraph">
<p>Stop the timer, and if it is repeating restart it using the repeat value as the timeout.</p>
</div>
</div>
<div class="sect2">
<h3 id="_timerset_repeatperiod"><a class="anchor" href="#_timerset_repeatperiod"></a>timer:set_repeat(period)</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">period</dt>
<dd>
<p>repeat period in seconds, <code>0</code> to disable</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_timerget_repeat"><a class="anchor" href="#_timerget_repeat"></a>timer:get_repeat()</h3>
<div class="paragraph">
<p>Get the repeat period (in seconds).</p>
</div>
</div>
<div class="sect2">
<h3 id="_timerget_due_in"><a class="anchor" href="#_timerget_due_in"></a>timer:get_due_in()</h3>
<div class="paragraph">
<p>Get the timer due value (in seconds, <code>0</code> if expired).</p>
</div>
</div>
<div class="sect2">
<h3 id="_loopasynccallback"><a class="anchor" href="#_loopasynccallback"></a>loop:async(callback)</h3>
<div class="paragraph">
<p>Create an async handle.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">callback</dt>
<dd>
<p><code>(async)</code></p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="async-send"><a class="anchor" href="#async-send"></a>async:send()</h3>
<div class="paragraph">
<p>Wake up the event loop and call the async handle’s callback.</p>
</div>
</div>
<div class="sect2">
<h3 id="_loopsignal"><a class="anchor" href="#_loopsignal"></a>loop:signal()</h3>
<div class="paragraph">
<p>Create a signal handle.</p>
</div>
</div>
<div class="sect2">
<h3 id="_signalstartsignum_callback"><a class="anchor" href="#_signalstartsignum_callback"></a>signal:start(signum, callback)</h3>
<div class="paragraph">
<p>Start watching for the given signal.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">signum</dt>
<dd>
<p>signal number</p>
</dd>
<dt class="hdlist1">callback</dt>
<dd>
<p><code>(signal, signum)</code></p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_signalstart_oneshotsignum_callback"><a class="anchor" href="#_signalstart_oneshotsignum_callback"></a>signal:start_oneshot(signum, callback)</h3>
<div class="paragraph">
<p>Same as <code>start()</code>, but the signal handler is reset the moment the signal is received.</p>
</div>
</div>
<div class="sect2">
<h3 id="_signalstop"><a class="anchor" href="#_signalstop"></a>signal:stop()</h3>
<div class="paragraph">
<p>Stop watching for signals.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2022-01-20 01:26:44 +0100
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
</body>
</html>